{"name":"Basilik","tagline":"Ruby implementation for Firebase","body":"# Basilik - Ruby firepower to your Firebase batteries\r\n\r\nFirebase is a real-time backend that allows one to store key-value pairs in a hierarchical fashion, without\r\nhaving to manage additional servers. Firebase offers api's for a variety of client libs such as javascript, \r\nREST, IOS and now Ruby ;-). A cool thing about Firebase is that it broadcast changes to a variety of clients listening\r\non a given firebase and allows disparate client to share their data. Checkout http://firebase.com for the firehose...\r\n\r\n## Requirements\r\n\r\n- Ruby >= 1.9\r\n- Map\r\n- Typhoeus\r\n\r\n## Getting Started\r\n\r\n$ gem install basilik\r\n\r\n## Usage\r\n\r\n### Setup your Firebase\r\n\r\nSign up for a firebase account and create a new firebase of your liking.\r\nIn the following code samples, we will use the following as our base url:\r\n\r\n+ https://zerodarkthirty.firebaseio.com\r\n\r\nThen you can specify an entry point into the data using the following call:\r\n\r\n```ruby\r\nref = Basilik::Load.new( 'https://zerodarkthirty.firebaseio.com' )\r\n```\r\n\r\nNOTE: You don't have to start a the root, but usually a good idea since this api\r\noffers ways to traverse the hierarchy up or down. But more on this later...\r\n\r\n\r\n### Populating firebase\r\n\r\nFirebase supports the following data types:\r\n\r\n+ String\r\n+ Number\r\n+ Boolean\r\n+ Array\r\n+ Hash\r\n\r\n#### Adding primitive types\r\n\r\n```ruby\r\ndata = {\r\n  a: 0,\r\n  b: %s(Hello World),\r\n  c: 10.5\r\n}\r\nref.set( data )\r\n```\r\n\r\nYields:\r\n\r\n+ a:0\r\n+ b:\"Hello World\"\r\n+ c:10.5\r\n\r\nNOTE: Set is a destructive operation and will replace the previous content for the reference it is\r\ncalled from.\r\n\r\nThus \r\n\r\n```ruby\r\ndata = {\r\n  a: 0\r\n}\r\nref.set( data )\r\n```\r\n\r\nYields\r\n+ a:0\r\n\r\nHence replacing the previously assigned content.\r\n\r\n\r\n#### Adding arrays\r\n\r\n```ruby\r\nref.set( %w(Hello World) )\r\n```\r\n\r\nYields:\r\n\r\n+ 0:\"Hello\"\r\n+ 1:\"World\"\r\n\r\n\r\n#### Adding arrays (ordered data)\r\n\r\nThe preferred method to construct lists in your firebase is to use the push operation, which\r\nwill automatically provide ordering to your list.\r\n\r\n```ruby\r\nref.push( \"BumbleBee\" )\r\nref.push( \"Tuna\" )\r\n```\r\n\r\nYields:\r\n  \r\n+ -IrMr3Yp1mozVNzDePKy: \"BumbleBee\"\r\n+ -IrMr3cM6XjTpNebsYRh: \"Tuna\"\r\n\r\nNOTE: The list indexes will be autogenerated by firebase to ensure correct ordering on retrieval.\r\n\r\n\r\n#### Adding hashes\r\n\r\n```ruby\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: 10.5    \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\nYields:\r\n\r\n+ a:\r\n  + a_1:\"Hello World\"\r\n  + a_2_:10.5\r\n+ b:\r\n  + b_1:10\r\n  + b_2:true\r\n    \r\n   \r\n### Reading data\r\n\r\nFetching data in the hierarchy is done via the read operation.\r\n\r\n```ruby\r\n# Setup...\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: 10.5    \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\n```ruby\r\nref.child( 'a/a_2' ).read # => 10.5\r\na_val = ref.child( :a ).read \r\na_val.a_1    # => 'Hello World'\r\na_val[:a_1]  # => 'Hello World' or use hash indexing...\r\na_val.a_2    # => 10.5\r\n```\r\n\r\n### Updating data\r\n\r\nYou can use the #update on a reference to modify nodes in the hierarchy\r\n\r\n```ruby\r\n# Setup...\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: {\r\n      a_2_1: 10.5,\r\n      a_2_2: \"Word!\"\r\n    }   \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\n```ruby\r\nref.child( :a ).update( a_1:\"BumbleBee Tuna\" )\r\nref.child( 'a/a_2' ).update( a_2_2:\"You bet!\" )\r\nref.child( 'a' ).child( 'a_3' ).update( a_3_1:\"You better!\" )\r\n```\r\n\r\nYields:\r\n\r\n+ a\r\n  + a_1:\"BumbleBee Tuna\"\r\n  + a_2\r\n    + a_2_1: 10.5\r\n    + a_2_2: \"You bet!\"\r\n    + a_3\r\n      + a_3_1: \"You better!\"\r\n      \r\nNote: the last call inserts a branch new node in the hierarchy. We could have use set here as well to\r\nperform the insert.\r\n\r\nYou can leverage #inc/#dec to increment/decrement counter like data.\r\n\r\nIMPORTANT! Sadly Firebase currently does not offer transactions using their REST api, hence there is\r\nno guarantees about the atomicity of read/write operations ;-(\r\n\r\n### Deleting data\r\n\r\nUse the #remove operation to delete nodes at any level in the hierarchy.\r\n\r\n```ruby\r\n# Setup...\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: {\r\n      a_2_1: 10.5,\r\n      a_2_2: \"Word!\"\r\n    }   \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\nref.child( 'a/a_2/a_2_2' ).remove\r\nref.child( :b ).remove\r\n```\r\n\r\nNOTE: Calling remove on the root ref will delete the entire hierarchy.\r\n\r\n### Traversing the data\r\n\r\nYou can traverse the hierarchy using the #child or #parent. These calls can be chained.\r\n\r\n```ruby\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: {\r\n      a_2_1: 10.5,\r\n      a_2_2: \"Word!\"\r\n    }   \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\n```ruby\r\na_2_2_ref = ref.child( 'a/a_2/a_2_2' )\r\na_2_2_ref = ref.child( :a ).child( :a_2 ).child( :a_2_2 ) # or...\r\na_2_2_ref.name #=> 'a_2_2'\r\n\r\na_2_ref = a_2_2_ref.parent\r\na_2_ref.name   # => 'a_2'\r\n\r\na_ref = a_2_2_ref.parent.parent\r\na_ref.name     # => 'a'\r\n```\r\n      \r\n### Priorities\r\n\r\nFirebase provides for setting priorities on ordered list in order to affect the retrieval. By default priority is null.\r\nSetting priority affects the retrieval as follows (See firebase web site for details!):\r\n\r\n+ Children with no priority are retrieved first ordered lex asc by name\r\n+ Children with number priority are next, ordered lex asc priority, name\r\n+ Children with a non numeric priority come last, ordered lex asc priority, name\r\n\r\n```ruby\r\na_ref = ref.push( {a:1, b:2} )\r\nb_ref = ref.push( {c:1, d:2} )\r\na_ref.set_priority( 20 )\r\nb_ref.set_priority( 10 ) \r\na_ref.parent.read #=> {-IrNhTASqxqEpNMw8NGq: {c: 1, d: 2}, -IrNhT2vsoQ1WlgSG6op: {a: 1, b: 2} }\r\n```\r\n\r\n### Auth and rules\r\n\r\nYou can secure you firebase store using a secret token and grant access for permissions on the store using rules.\r\nPlease refer to the firebase docs for details.\r\n\r\n```ruby\r\nref = Basilik::Load.new( 'https://bozo.firebaseio.com', my_secret_token )\r\nref.set( tmp: { a: 0, b: 1 } )\r\nref.set_rules( \r\n  { '.read' => true, '.write' => false, \r\n     \"tmp\"  => { '.read' => true, '.write' => false }\r\n  }\r\n)\r\nres = ref.child(:tmp).read # => { a: 0, b: 1 }\r\nref.set( tmp: {d:0} ) } # => Basilik::Action::PermissionDeniedError\r\n```\r\n\r\n## Contact\r\n\r\nFernand Galiana\r\n\r\n- http://github.com/derailed\r\n- http://twitter.com/kitesurfer\r\n- <fernand.galiana@gmail.com>\r\n\r\n## License\r\n\r\nBasilik is released under the [MIT](http://opensource.org/licenses/MIT) license.\r\n\r\n\r\n## History\r\n  0.0.1:\r\n    - Initial drop","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}