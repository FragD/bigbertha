{"name":"BigBertha","tagline":"Ruby firepower for your Firebase battery!","body":"Firebase is a real-time backend that allows one to store key-value pairs in a hierarchical fashion, without\r\nhaving to manage additional servers. Firebase offers api's for a variety of client libs such as javascript, REST, IOS and now Ruby ;-). A cool feature of firebase is that it allows disparate clients to broadcast updates and sync up across the wire. Checkout http://firebase.com for the firehose...\r\n\r\n## Requirements\r\n\r\n- Ruby >= 1.9\r\n- Map\r\n- Typhoeus\r\n- Values\r\n- firebase_token_generator\r\n\r\n## Getting Started\r\n\r\n$ gem install bigbertha\r\n\r\n## Usage\r\n\r\n### Setup your Firebase\r\n\r\nSign up for a firebase account and create a new firebase of your liking.\r\nIn the following code samples, we will use the following as our base url:\r\n\r\n+ https://zerodarkthirty.firebaseio.com\r\n\r\nThen you can specify an entry point into the data using the following call:\r\n\r\n```ruby\r\nref = Bigbertha::Ref.new( 'https://zerodarkthirty.firebaseio.com' )\r\n```\r\n\r\nNOTE: You don't have to start a the root, but usually a good idea since this api\r\noffers ways to traverse the hierarchy up or down. But more on this later...\r\n\r\n\r\n### Populating firebase\r\n\r\nFirebase supports the following data types:\r\n\r\n+ String\r\n+ Number\r\n+ Boolean\r\n+ Array\r\n+ Hash\r\n\r\n#### Adding primitive types\r\n\r\n```ruby\r\ndata = {\r\n  a: 0,\r\n  b: %s(Hello World),\r\n  c: 10.5\r\n}\r\nref.set( data )\r\n```\r\n\r\nYields:\r\n\r\n+ a:0\r\n+ b:\"Hello World\"\r\n+ c:10.5\r\n\r\nNOTE: Set is a destructive operation and will replace the previous content for the reference it is\r\ncalled from.\r\n\r\nThus \r\n\r\n```ruby\r\ndata = {\r\n  a: 0\r\n}\r\nref.set( data )\r\n```\r\n\r\nYields\r\n+ a:0\r\n\r\nHence replacing the previously assigned content.\r\n\r\n\r\n#### Adding arrays\r\n\r\n```ruby\r\nref.set( %w(Hello World) )\r\n```\r\n\r\nYields:\r\n\r\n+ 0:\"Hello\"\r\n+ 1:\"World\"\r\n\r\n\r\n#### Adding arrays (ordered data)\r\n\r\nThe preferred method to construct lists in your firebase is to use the push operation, which\r\nwill automatically provide ordering to your list.\r\n\r\n```ruby\r\nref.push( \"BumbleBee\" )\r\nref.push( \"Tuna\" )\r\n```\r\n\r\nYields:\r\n  \r\n+ -IrMr3Yp1mozVNzDePKy: \"BumbleBee\"\r\n+ -IrMr3cM6XjTpNebsYRh: \"Tuna\"\r\n\r\nNOTE: The list indexes will be autogenerated by firebase to ensure correct ordering on retrieval.\r\n\r\n\r\n#### Adding hashes\r\n\r\n```ruby\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: 10.5    \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\nYields:\r\n\r\n+ a:\r\n  + a_1:\"Hello World\"\r\n  + a_2_:10.5\r\n+ b:\r\n  + b_1:10\r\n  + b_2:true\r\n    \r\n   \r\n### Reading data\r\n\r\nFetching data in the hierarchy is done via the read operation.\r\n\r\n```ruby\r\n# Setup...\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: 10.5    \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\n```ruby\r\nref.child( :a, :a_2 ).read # => 10.5\r\n# or...\r\nref.child( :a, :a_2 ).val  # => 10.5\r\na_val = ref.child( :a ).read \r\na_val.a_1    # => 'Hello World'\r\na_val[:a_1]  # => 'Hello World' or use hash indexing...\r\na_val.a_2    # => 10.5\r\n```\r\n\r\n### Updating data\r\n\r\nYou can use the #update on a reference to modify nodes in the hierarchy\r\n\r\n```ruby\r\n# Setup...\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: {\r\n      a_2_1: 10.5,\r\n      a_2_2: \"Word!\"\r\n    }   \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\n```ruby\r\nref.child( :a ).update( a_1:\"BumbleBee Tuna\" )\r\nref.child( 'a/a_2' ).update( a_2_2:\"You bet!\" )\r\nref.child( 'a' ).child( 'a_3' ).update( a_3_1:\"You better!\" )\r\n```\r\n\r\nYields:\r\n\r\n+ a\r\n  + a_1:\"BumbleBee Tuna\"\r\n  + a_2\r\n      + a_2_1: 10.5\r\n      + a_2_2: \"You bet!\"\r\n  + a_3\r\n      + a_3_1: \"You better!\"\r\n      \r\nNote: the last call inserts a branch new node in the hierarchy. We could have use set here as well to\r\nperform the insert.\r\n\r\nYou can leverage #inc/#dec to increment/decrement counter like data.\r\n\r\nIMPORTANT! Sadly Firebase currently does not offer transactions using their REST api, hence there is\r\nno guarantees about the atomicity of read/write operations ;-(\r\n\r\n### Deleting data\r\n\r\nUse the #remove operation to delete nodes at any level in the hierarchy.\r\n\r\n```ruby\r\n# Setup...\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: {\r\n      a_2_1: 10.5,\r\n      a_2_2: \"Word!\"\r\n    }   \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\nref.child( 'a/a_2/a_2_2' ).remove\r\nref.child( :b ).remove\r\n```\r\n\r\nNOTE: Calling remove on the root ref will delete the entire hierarchy.\r\n\r\n### Traversing the data\r\n\r\nYou can traverse the hierarchy using the #child or #parent. These calls can be chained.\r\n\r\n```ruby\r\ndata = {\r\n  a: {\r\n    a_1: %s(Hello World),    \r\n    a_2: {\r\n      a_2_1: 10.5,\r\n      a_2_2: \"Word!\"\r\n    }   \r\n  },\r\n  b: {\r\n    b_1: 10,\r\n    b_2: true\r\n  }\r\n}\r\nref.set( data )\r\n```\r\n\r\n```ruby\r\na_2_2_ref = ref.child( 'a/a_2/a_2_2' )\r\n# or...\r\na_2_2_ref = ref.child( :a ).child( :a_2 ).child( :a_2_2 ) \r\n# or...\r\na_2_2_ref = ref.child( :a, :a_2, :a_2_2 )\r\n# or...\r\na_2_2_ref = ref.child( %w(a a_2 a_2_2) )\r\na_2_2_ref.name #=> 'a_2_2'\r\n\r\na_2_ref = a_2_2_ref.parent\r\na_2_ref.name   # => 'a_2'\r\n\r\na_ref = a_2_2_ref.parent.parent\r\na_ref.name     # => 'a'\r\n```\r\n      \r\n### Priorities\r\n\r\nFirebase provides for setting priorities on ordered list in order to affect the retrieval. By default priority is null.\r\nSetting priority affects the retrieval as follows (See firebase web site for details!):\r\n\r\n+ Children with no priority are retrieved first ordered lex asc by name\r\n+ Children with number priority are next, ordered lex asc priority, name\r\n+ Children with a non numeric priority come last, ordered lex asc priority, name\r\n\r\n```ruby\r\na_ref = ref.push( {a:1, b:2} )\r\nb_ref = ref.push( {c:1, d:2} )\r\na_ref.set_priority( 20 )\r\nb_ref.set_priority( 10 ) \r\na_ref.parent.read #=> {-IrNhTASqxqEpNMw8NGq: {c: 1, d: 2}, -IrNhT2vsoQ1WlgSG6op: {a: 1, b: 2} }\r\n```\r\n\r\n### Auth and rules\r\n\r\nYou can secure you firebase store using a secret token and grant access for permissions on the store using rules.\r\nPlease refer to the firebase docs for details.\r\n\r\nNote: We've encapsulated the Firebase auth token generator ruby implementation to make generating tokens\r\nmore convenient. \r\n\r\n```\r\n> bb_auth_token -h\r\n> bb_auth_token SECRET --data \"{\\\"user\\\":\\\"bozo\\\"}\"\r\n```\r\n\r\n```ruby\r\nref = Bigbertha::Ref.new( 'https://bozo.firebaseio.com', auth_token|secret )\r\nref.set( tmp: { a: 0, b: 1 } )\r\nref.set_rules( \r\n  { \r\n    '.read'  => true, \r\n    '.write' => \"auth.user == 'bozo'\", \r\n     \"tmp\"   => { \r\n       '.read'  => true, \r\n       '.write' => false \r\n     }\r\n  }\r\n)\r\nres = ref.child(:tmp).read # => { a: 0, b: 1 }\r\nref.set( tmp: {d:0} ) } # => Bigbertha::Action::PermissionDeniedError\r\n```\r\n\r\n## Contact\r\n\r\nFernand Galiana\r\n\r\n- http://github.com/derailed\r\n- http://twitter.com/kitesurfer\r\n- <fernand.galiana@gmail.com>\r\n\r\nStill work in progress. So please feel free to contact me if you run into issues or\r\njust want to touch base...\r\n\r\n## License\r\n\r\nBigbertha is released under the [MIT](http://opensource.org/licenses/MIT) license.\r\n\r\n\r\n## History\r\n  + 0.0.1:\r\n    + Initial drop\r\n  + 0.0.2:\r\n    + Clean up and doc updates\r\n  + 0.0.3:\r\n    + Updated gemspec\r\n  + 0.0.4:\r\n    + Added command line exec bb_auth_token to generate auth tokens\r\n    + Added splat args to child\r\n    + Deprecated Load. Use Ref from now on","google":"UA-39871145-1","note":"Don't delete this file! It's used internally to help with page regeneration."}